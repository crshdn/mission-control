{"id":"chatcmpl-DCsCPoHIMllgVn5yWjeYbMqw45OXL","created":1771960667,"model":"copilot-claude-sonnet","object":"chat.completion","choices":[{"finish_reason":"stop","index":0,"message":{"content":"# SETUP_ASSIST.md\n\nPurpose\n- Short checklist and tiny scripts you can add to this repo to verify network and protocol connectivity to an OpenClaw gateway.\n- Replace placeholders (UPPERCASE or ${VAR}) with your real values.\n\nQuick variables (set in CI or locally)\n- GATEWAY_HOST (IP or hostname)\n- API_PORT (HTTP/REST port, e.g. 8080)\n- API_TOKEN (Bearer or API key used for REST)\n- WS_PATH (WebSocket path, e.g. /ws)\n- MQTT_HOST (same as GATEWAY_HOST or broker host)\n- MQTT_PORT (usually 1883 or 8883)\n- MQTT_TOPIC (test topic, e.g. openclaw/health)\n- TLS (true if TLS/HTTPS/MQTTs is used — adjust ports and proto accordingly)\n\nChecklist (concise, actionable)\n1. Prereqs\n   - Install common CLI tools:\n     - curl, netcat/nc, openssl\n     - (optional) mosquitto-clients (mosquitto_pub/sub)\n     - (optional) pip modules: websocket-client (for WS script) or install websocat/wscat\n2. Basic network reachability\n   - ping GATEWAY_HOST\n   - traceroute (if needed)\n3. TCP/port reachable\n   - nc -zv GATEWAY_HOST API_PORT\n   - or: timeout 3 bash -c \"cat < /dev/null > /dev/tcp/GATEWAY_HOST/API_PORT\" (bash)\n4. REST API check (authenticated)\n   - Use curl with API_TOKEN to hit a known health/status endpoint\n5. WebSocket check\n   - Attempt an upgrade and exchange a small message (use websocat/wscat or websocket-client)\n6. MQTT pub/sub check\n   - Subscribe and publish a short message to verify round-trip\n7. TLS cert (if applicable)\n   - Use openssl s_client to inspect certificate chain\n8. Add scripts to repository and run in CI to fail fast on connectivity regressions\n\nAdd to repo: scripts (make executable)\n- Create a folder `scripts/` and add these three files.\n\nscripts/check_http.sh\n```bash\n#!/usr/bin/env bash\n# Usage: GATEWAY_HOST=... API_PORT=... API_TOKEN=... ./scripts/check_http.sh\nset -eo pipefail\n\n: \"${GATEWAY_HOST:?set GATEWAY_HOST}\"\n: \"${API_PORT:=8080}\"\n: \"${API_TOKEN:?set API_TOKEN}\"\n\nURL=\"http://${GATEWAY_HOST}:${API_PORT}/status\"\n\n# If TLS, change http:// to https:// and API_PORT accordingly\nif [[ \"${TLS:-false}\" == \"true\" ]]; then\n  URL=\"https://${GATEWAY_HOST}:${API_PORT}/status\"\nfi\n\necho \"Checking HTTP ${URL}\"\nHTTP_CODE=$(curl -s -o /dev/null -w \"%{http_code}\" -H \"Authorization: Bearer ${API_TOKEN}\" \"${URL}\" --max-time 5)\n\nif [[ \"$HTTP_CODE\" == \"200\" || \"$HTTP_CODE\" == \"204\" ]]; then\n  echo \"HTTP OK (${HTTP_CODE})\"\n  exit 0\nelse\n  echo \"HTTP check failed: ${HTTP_CODE}\"\n  exit 2\nfi\n```\n\nscripts/check_ws.py\n```python\n#!/usr/bin/env python3\n# Usage: GATEWAY_HOST=... API_PORT=... WS_PATH=/ws python3 scripts/check_ws.py\n# Requires: pip install websocket-client\nimport os, sys, time\nfrom websocket import create_connection, WebSocketTimeoutException\n\nhost = os.environ.get(\"GATEWAY_HOST\")\nport = os.environ.get(\"API_PORT\", \"8080\")\npath = os.environ.get(\"WS_PATH\", \"/ws\")\nuse_tls = os.environ.get(\"TLS\", \"false\") == \"true\"\n\nif not host:\n    print(\"set GATEWAY_HOST\", file=sys.stderr); sys.exit(3)\n\nproto = \"wss\" if use_tls else \"ws\"\nurl = f\"{proto}://{host}:{port}{path}\"\nprint(\"Connecting to\", url)\n\ntry:\n    ws = create_connection(url, timeout=5)\n    # send a small ping/hello if the gateway expects text frames\n    ws.send(\"ping\")\n    try:\n        ws.settimeout(5)\n        msg = ws.recv()\n        print(\"Received:\", msg)\n    except WebSocketTimeoutException:\n        print(\"No response within timeout (this may be expected for a ping)\")\n    ws.close()\n    print(\"WebSocket OK\")\n    sys.exit(0)\nexcept Exception as e:\n    print(\"WebSocket connection failed:\", e, file=sys.stderr)\n    sys.exit(2)\n```\n\nscripts/check_mqtt.sh\n```bash\n#!/usr/bin/env bash\n# Usage: MQTT_HOST=... MQTT_PORT=... MQTT_TOPIC=... ./scripts/check_mqtt.sh\nset -euo pipefail\n\n: \"${MQTT_HOST:?set MQTT_HOST}\"\n: \"${MQTT_PORT:=1883}\"\n: \"${MQTT_TOPIC:?set MQTT_TOPIC}\"\n\n# Temporary file for subscriber output\nOUT=$(mktemp)\ntrap 'rm -f \"$OUT\"' EXIT\n\n# Start a subscriber in background. Requires mosquitto_sub\ntimeout 6 mosquitto_sub -h \"${MQTT_HOST}\" -p \"${MQTT_PORT}\" -t \"${MQTT_TOPIC}\" -C 1 > \"${OUT}\" 2>/dev/null &\nSUB_PID=$!\n\n# Give subscriber a moment to connect\nsleep 0.5\n\n# Publish a test message. Requires mosquitto_pub\nmosquitto_pub -h \"${MQTT_HOST}\" -p \"${MQTT_PORT}\" -t \"${MQTT_TOPIC}\" -m \"openclaw-test-$(date +%s%N)\" >/dev/null 2>&1 || true\n\n# Wait for subscriber to finish (timeout will kill it if not received)\nwait ${SUB_PID} || true\n\nif [[ -s \"${OUT}\" ]]; then\n  echo \"MQTT round-trip OK: $(cat ${OUT})\"\n  exit 0\nelse\n  echo \"MQTT check failed: no message received\"\n  exit 4\nfi\n```\n\nMake scripts executable\n```bash\nchmod +x scripts/check_http.sh scripts/check_ws.py scripts/check_mqtt.sh\n```\n\nQuick manual commands (one-liners)\n- Ping:\n  - ping -c 3 ${GATEWAY_HOST}\n- TCP port:\n  - nc -zv ${GATEWAY_HOST} ${API_PORT}\n- REST health:\n  - curl -v -H \"Authorization: Bearer ${API_TOKEN}\" http://${GATEWAY_HOST}:${API_PORT}/status\n- WebSocket (with websocat):\n  - websocat \"ws://${GATEWAY_HOST}:${API_PORT}${WS_PATH}\"\n- WebSocket (with wscat):\n  - npx wscat -c \"ws://${GATEWAY_HOST}:${API_PORT}${WS_PATH}\"\n- TLS cert:\n  - openssl s_client -connect ${GATEWAY_HOST}:${API_PORT} -showcerts\n- MQTT pub/sub (quick):\n  - mosquitto_sub -h ${MQTT_HOST} -p ${MQTT_PORT} -t ${MQTT_TOPIC} -C 1 &\n  - mosquitto_pub -h ${MQTT_HOST} -p ${MQTT_PORT} -t ${MQTT_TOPIC} -m \"test\"\n\nCI snippet (GitHub Actions job)\n```yaml\n# minimal job to run connectivity checks\njobs:\n  connectivity:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Install deps\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y curl netcat-openbsd mosquitto-clients\n          pip install websocket-client\n      - name: Run checks\n        env:\n          GATEWAY_HOST: ${{ secrets.GATEWAY_HOST }}\n          API_PORT: ${{ secrets.API_PORT }}\n          API_TOKEN: ${{ secrets.API_TOKEN }}\n          WS_PATH: ${{ secrets.WS_PATH }}\n          MQTT_TOPIC: ${{ secrets.MQTT_TOPIC }}\n          MQTT_PORT: ${{ secrets.MQTT_PORT }}\n        run: |\n          chmod +x scripts/*.sh scripts/*.py\n          ./scripts/check_http.sh\n          python3 scripts/check_ws.py\n          ./scripts/check_mqtt.sh\n```\n\nExpected behavior and exit codes\n- Each script prints a one-line success message and exits 0 on success.\n- Non-zero exit codes indicate failure; CI should fail fast on these.\n\nTroubleshooting tips\n- If ping is blocked, try nc/tcp checks — ICMP may be disabled.\n- If REST returns 401/403 check API_TOKEN and Authorization header format.\n- For TLS, verify CA or client certs if using mTLS.\n- For MQTTs, use port 8883 and provide TLS options (mosquitto_pub/sub --cafile/--cert/--key).\n- Increase timeouts if gateway is slow to boot.\n\nThat's it — add the three scripts into scripts/, commit, and wire into your CI to get automated connectivity verification for the OpenClaw gateway.","role":"assistant","provider_specific_fields":{"refusal":null,"padding":"abcdefghijklmnopqrstuvw"}},"provider_specific_fields":{"content_filter_results":{}}}],"usage":{"completion_tokens":2758,"prompt_tokens":44,"total_tokens":2802,"completion_tokens_details":{"accepted_prediction_tokens":0,"rejected_prediction_tokens":0},"prompt_tokens_details":{"cached_tokens":0}}}